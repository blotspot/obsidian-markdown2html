import { App, Component, debounce, MarkdownRenderer, Notice, Platform } from "obsidian";
import { Markdown2HtmlSettings } from "settings";
import CopyInProgressModal from "ui/copy-modal";
import { isEmpty, Log, removeEmptyLines } from "utils/helper";

export default class CopyHtml {
  private app: App;
  private modal: CopyInProgressModal;

  private inProgress: boolean = false;
  // eslint-disable-next-line no-undef
  private htmlRoot: HTMLDivElement = createDiv();
  private copyComponent = new Component();

  constructor(app: App) {
    this.app = app;
    this.modal = new CopyInProgressModal(app);
    this.copyComponent.load();
  }

  /** triggers the render of the markdown note or selection. */
  async renderHtml(content: Promise<string>) {
    try {
      this.startCopyProcess();
      const path = this.app.workspace.activeEditor?.file?.path ?? "";
      void MarkdownRenderer.render(this.app, await content, this.htmlRoot, path, this.copyComponent);
    } catch (e) {
      Log.e("Error while rendering HTML", e);
      new Notice("Error while rendering HTML", 3500);
      this.endCopyProcess();
    }
  }

  /**
   * Cleans up the rendered HTML and stores it in the system clipboard.
   * Executes after a short delay to make sure all steps of the rendering are done.
   * Each time the method is called within the delay, the timer resets.
   */
  copyToClipboard = debounce(
    async (settings: Markdown2HtmlSettings) => {
      if (this.copyInProgress()) {
        Log.d("Rendering finished, cleaning HTML...");
        const data = await this.cleanHtml(settings);
        Log.d("Copying HTML to clipboard...");
        let clipboardWrite: Promise<void>;
        if (Platform.isDesktopApp) {
          const item = new ClipboardItem({
            "text/plain": new Blob([data], { type: "text/plain" }),
            "text/html": new Blob([data], { type: "text/html" }),
          });
          clipboardWrite = navigator.clipboard.write([item]);
        } else {
          // mobile obsidian can't do the fancy stuff with html mime type
          clipboardWrite = navigator.clipboard.writeText(data);
        }
        clipboardWrite
          .then(() => new Notice("HTML copied to the clipboard", 3500))
          .catch(e => {
            Log.e("Error while copying HTML to the clipboard", e);
            new Notice("Couldn't copy HTML to the clipboard", 3500);
          })
          .finally(() => this.endCopyProcess());
      }
    },
    250 /* wait delay until copy to clipboard happens */,
    true /* reset delay if method is called before timer finishes */
  );

  copyInProgress() {
    return this.inProgress;
  }

  private startCopyProcess() {
    Log.d("Starting copy process...");
    this.inProgress = true;
    this.modal.open();
  }

  private endCopyProcess() {
    this.inProgress = false;
    this.htmlRoot.empty();
    this.modal.close();
    Log.d("Copy process finished.");
  }

  /**
   * runs a few steps to clean the HTML generated by Obsidian's internal markdown renderer.
   *
   * @param settings the settings of the plugin
   */
  private async cleanHtml(settings: Markdown2HtmlSettings) {
    this.removeEmptyContainer();
    this.removeAttributes(settings);
    await this.convertImages();

    const html = removeEmptyLines(this.htmlRoot.innerHTML);
    return html;
  }

  /** remove all child nodes that don't have any content (removes empty paragraphs left by comments) */
  private removeEmptyContainer() {
    this.htmlRoot.querySelectorAll("p, div").forEach(node => {
      if (isEmpty(node.innerHTML)) {
        node.remove();
      }
    });
  }

  /** Remove all irrelevant attributes of elements */
  private removeAttributes(settings: Markdown2HtmlSettings) {
    const elements = this.htmlRoot.querySelectorAll<HTMLElement>("*");

    elements.forEach(element => {
      const attributesToRemove: string[] = [];
      const classesToKeep: string[] = Object.assign([], settings.classList).filter(cls =>
        element.classList.contains(cls)
      );

      const attributes = element.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attribute = attributes[i];
        if (!attribute || typeof attribute.name !== "string") {
          continue;
        }
        const attrName = attribute.name.toLowerCase();
        if (!settings.attributeList.contains(attrName)) {
          attributesToRemove.push(attrName);
        }
      }
      // remove all attributes that are not allowed
      attributesToRemove.forEach(attr => element.removeAttribute(attr));
      // readd classes to keep
      element.addClasses(classesToKeep);
    });
  }

  /** Convert internal Images to base64 data URL */
  private async convertImages() {
    const images: NodeListOf<HTMLImageElement> = this.htmlRoot.querySelectorAll('img:not([src^="http"])');
    for (let i = 0; i < images.length; i++) {
      const image = images[i];
      if (!image || typeof image.src !== "string") {
        continue;
      }
      image.src = await this.toBase64(image.src);
    }
  }

  /** Read a file from an uri and turn it into a base64 string */
  private async toBase64(src: string) {
    Log.d(`Converting internal image to base64: ${src}`);
    // Note: using fetch instead of requestUrl because requestUrl only works with http(s) URLs
    //       and we want to resolve an internal file URL.
    // eslint-disable-next-line no-restricted-globals
    return fetch(src)
      .then(res => res.blob())
      .then(
        blob =>
          new Promise<FileReader>((resolve, error) => {
            let fr = new FileReader();
            fr.onload = () => resolve(fr);
            fr.onerror = () => error(new Error("Failed to read blob as data URL"));
            fr.readAsDataURL(blob);
          })
      )
      .then(fr => fr.result as string)
      .then(dataUrl => {
        if (dataUrl.length <= 100000) {
          return dataUrl;
        } else {
          Log.w(`Image too large to convert to base64, keeping original src: ${src}`);
          return src; // fallback to original src if image is too large
        }
      })
      .catch(e => {
        Log.e(`Error while converting image to base64: ${src}`, e);
        return src; // fallback to original src if conversion fails
      });
  }
}
