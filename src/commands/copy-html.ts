import {
  App,
  arrayBufferToBase64,
  Component,
  debounce,
  Editor,
  MarkdownRenderer,
  Notice,
  requestUrl,
  TFile,
} from "obsidian";
import { Markdown2HtmlSettings } from "settings";
import CopyInProgressModal from "ui/copy-modal";
import { getContent, isEmpty, Log, removeEmptyLines } from "utils/helper";

export default class CopyHtml {
  private app: App;
  private modal: CopyInProgressModal;

  private inProgress: boolean = false;
  // eslint-disable-next-line no-undef
  private htmlRoot: HTMLDivElement = createDiv();
  private copyComponent = new Component();

  constructor(app: App) {
    this.app = app;
    this.modal = new CopyInProgressModal(app);
    this.copyComponent.load();
  }

  /** triggers the render of the markdown note or selection. */
  async renderHtml(contentProvider: Editor | TFile) {
    try {
      this.startCopyProcess();
      const path = this.app.workspace.activeEditor?.file?.path ?? "";
      const content = await getContent(this.app, contentProvider);
      void MarkdownRenderer.render(this.app, content, this.htmlRoot, path, this.copyComponent);
    } catch (e) {
      Log.e("Error while rendering HTML", e);
      new Notice("Error while rendering HTML", 3500);
      this.endCopyProcess();
    }
  }

  /**
   * Cleans up the rendered HTML and stores it in the system clipboard.
   * Executes after a short delay to make sure all steps of the rendering are done.
   * Each time the method is called within the delay, the timer resets.
   */
  copyToClipboard = debounce(
    async (settings: Markdown2HtmlSettings) => {
      if (this.copyInProgress()) {
        Log.d("Rendering finished, cleaning HTML...");
        const data = await this.cleanHtml(this.htmlRoot, settings);
        Log.d("Copying HTML to clipboard...");
        const item = new ClipboardItem({
          "text/plain": new Blob([data], { type: "text/plain" }),
          "text/html": new Blob([data], { type: "text/html" }),
        });
        navigator.clipboard.write([item])
          .then(() => new Notice("HTML copied to the clipboard", 3500))
          .catch((e) => {
            Log.e("Error while copying HTML to the clipboard", e);
            new Notice("Couldn't copy HTML to the clipboard", 3500);
          })
          .finally(() => this.endCopyProcess());
      }
    },
    500 /* wait delay until copy to clipboard happens */,
    true /* reset delay if method is called before timer finishes */,
  );

  copyInProgress() {
    return this.inProgress;
  }

  private startCopyProcess() {
    Log.d("Starting copy process...");
    this.inProgress = true;
    this.modal.open();
  }

  private endCopyProcess() {
    this.inProgress = false;
    this.htmlRoot.empty();
    this.modal.close();
    Log.d("Copy process finished.");
  }


  /**
   * runs a few steps to clean the HTML generated by Obsidian's internal markdown renderer.
   *
   * @param parent the root element of the rendered HTML
   * @param settings the settings of the plugin
   */
  private async cleanHtml(parent: HTMLDivElement, settings: Markdown2HtmlSettings) {
    this.removeEmptyContainer(parent);
    this.removeFrontMatter(parent);
    this.removeAttributes(parent, settings);
    await this.convertImages(parent);

    const html = removeEmptyLines(parent.innerHTML);
    return html;
  }

  /** remove all child nodes that don't have any content (removes empty paragraphs left by comments) */
  private removeEmptyContainer(parent: HTMLElement) {
    parent.querySelectorAll("p, div").forEach((node) => {
      if (isEmpty(node.innerHTML)) {
        node.remove();
      }
    });
  }

  /** Remove frontmatter header */
  private removeFrontMatter(parent: HTMLElement) {
    const frontmatterNodes = parent.querySelectorAll(
      ".frontmatter, .frontmatter-container",
    );
    frontmatterNodes.forEach((node) => node.remove());
  }

  /** Remove all irrelevant attributes of elements */
  private removeAttributes(
    parent: HTMLElement,
    settings: Markdown2HtmlSettings,
  ) {
    const elements = parent.querySelectorAll<HTMLElement>("*");

    elements.forEach((element) => {
      const attributesToRemove: string[] = [];
      const classesToKeep: string[] = Object.assign(
        [],
        settings.classList,
      ).filter((cls) => element.classList.contains(cls));

      const attributes = element.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attribute = attributes[i];
        if (!attribute || typeof attribute.name !== "string") {
          continue;
        }
        const attrName = attribute.name.toLowerCase();
        if (!settings.attributeList.contains(attrName)) {
          attributesToRemove.push(attrName);
        }
      }
      // remove all attributes that are not allowed
      attributesToRemove.forEach((attr) => element.removeAttribute(attr));
      // readd classes to keep
      element.addClasses(classesToKeep);
    });
  }

  /** Convert internal Images to base64 data URL */
  private async convertImages(parent: HTMLElement) {
    const images: NodeListOf<HTMLImageElement> = parent.querySelectorAll(
      'img:not([src^="http"])',
    );
    for (let i = 0; i < images.length; i++) {
      const image = images[i];
      if (!image || typeof image.src !== "string") {
        continue;
      }
      image.src = await this.toBase64(image.src);
    }
  }

  /** Read a file from an uri and turn it into a base64 string */
  private async toBase64(src: string) {
    return await requestUrl(src).then((res) =>
      arrayBufferToBase64(res.arrayBuffer),
    );
  }
}
