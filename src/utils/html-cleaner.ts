import { arrayBufferToBase64, requestUrl } from "obsidian";
import { Markdown2HtmlSettings } from "../settings";
import { isEmpty, removeEmptyLines } from "./helper";

/**
 * runs a few steps to clean the HTML generated by Obsidian's internal markdown renderer.
 *
 * @param parent the root element of the rendered HTML
 * @param settings the settings of the plugin
 */
export async function cleanHtml(parent: HTMLElement, settings: Markdown2HtmlSettings) {
  removeEmptyContainer(parent);
  removeFrontMatter(parent);
  removeAttributes(parent, settings);
  await convertImages(parent);

  const html = removeEmptyLines(parent.innerHTML);
  return html;
}

/** remove all child nodes that don't have any content (removes empty paragraphs left by comments) */
function removeEmptyContainer(parent: HTMLElement) {
  parent.querySelectorAll("p, div").forEach(node => {
    if (isEmpty(node.innerHTML)) {
      node.remove();
    }
  });
}

/** Remove frontmatter header */
function removeFrontMatter(parent: HTMLElement) {
  const frontmatterNodes = parent.querySelectorAll(".frontmatter, .frontmatter-container");
  frontmatterNodes.forEach(node => node.remove());
}

/** Remove all irrelevant attributes of elements */
function removeAttributes(parent: HTMLElement, settings: Markdown2HtmlSettings) {
  const elements = parent.querySelectorAll<HTMLElement>("*");

  elements.forEach(element => {
    const attributesToRemove: string[] = [];
    const classesToKeep: string[] = Object.assign([], settings.classList).filter(cls =>
      element.classList.contains(cls)
    );

    const attributes = element.attributes;
    for (let i = 0; i < attributes.length; i++) {
      const attribute = attributes[i];
      if (!attribute || typeof attribute.name !== "string") {
        continue;
      }
      const attrName = attribute.name.toLowerCase();
      if (!settings.attributeList.contains(attrName)) {
        attributesToRemove.push(attrName);
      }
    }
    // remove all attributes that are not allowed
    attributesToRemove.forEach(attr => element.removeAttribute(attr));
    // readd classes to keep
    element.addClasses(classesToKeep);
  });
}

/** Convert internal Images to base64 data URL */
async function convertImages(parent: HTMLElement) {
  const images: NodeListOf<HTMLImageElement> = parent.querySelectorAll('img:not([src^="http"])');
  for (let i = 0; i < images.length; i++) {
    const image = images[i];
    if (!image || typeof image.src !== "string") {
      continue;
    }
    image.src = await toBase64(image.src);
  }
}

/** Read a file from an uri and turn it into a base64 string */
async function toBase64(src: string) {
  return await requestUrl(src)
    .then(res => arrayBufferToBase64(res.arrayBuffer));
}
